重载：(一个类里面的同名函数，函数体不同)
    c不能重载，编译成"_fun"的形式
    c++可以，编译成"?fun@@YA形参@Z"的形式，'H'表示'int','D'表示'cahr'
重写：(基类函数名前加virtual)
    子类中重新写该方法，使用基类指针或引用指向子类对象时，可调用到子类中实现的方法
隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏

static关键字：
    类外：
        变量：
            局部变量：存储于全局变量区，没初始化的话系统自动对其初始化，生命周期直到程序结束；
            全局变量：作用域只在本文件内，其他文件能定义相同变量(若无static的话作用域在本文件内外都存在)
        函数：
            与类外全局变量类似
    类内：
        成员变量：存储在全局变量区，使用之前必须初始化（在main之前），无this指针，不属于任何一个对象，只存在一个，所有对象都          可以操作，与静态全局变量相比，其不与程序中的其他全局变量冲突
        成员函数：与静态成员变量类似，无this指针，不属于任何一个对象，其不能是virtual、const 或 volatile

this指针：
    当一个对象调用某成员函数时会隐式传入一个参数， 这个参数就是this指针，this指针中存放的就是这个对象的首地址。编译器在生成程序时加入了获取对象首地址的相关代码。并把获取的首地址存放在了寄存器ECX中，类的静态成员函数因为没有this指针这个参数，所以类的静态成员函数也就无法调用类的非静态成员变量

虚函数：
    子类虚函数会覆盖每一个父类(多个)的每一个同名虚函数。(覆盖所有)
    父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。(往前挪到第一个)
    多个父类：1.都有虚函数(按声明顺序)；2.第一个没有虚函数（第一个父类往后挪到子类成员变量前面）

继承下的函数调用
    普通成员函数：从变量类型开始向上调用该类型最新实现的方法（多个父类同时有则报错,与变量类型有关)
    虚函数：调用该对象最新实现的方法(与具体对象类型有关)空类的对象占内存为1字节，继承自空类的类的对象中空类不占内存

构造函数可以为虚函数吗？
    虚函数相应一个指向vtable虚函数表的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的。假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数
   
析构函数为啥必须是虚函数
    考虑到父类指针指向子类对象时，就会从父类的析构函数开始调用，而不是子类的析构函数

子类初始化时构造函数调用过程
    父类->子类

纯虚函数
    带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。纯虚函数在子类中必须被重写

new和malloc：
    属性          关键字                  库函数
    指定内存大小   无需指定内存大小         需指明内存大小
    返回值不同     对应类型指针            void*
    构造函数调用   调用                   不调用
    分配失败时     抛出bac_alloc异常       返回NULL
    区域          自由存储区(可在全局区)   堆
    重载          operator new可重载      不能重载

const:
    修饰变量，说明该变量不可以被改变；
    修饰指针，分为指向常量的指针和指针常量；
    常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
    修饰成员函数，说明该成员函数内不能修改成员变量。修饰变量，说明该变量不可以被改变；

成员函数+const为啥不能修改成员变量？
    普通成员函数中编译器添加了函数参数this指针，默认为"ClassName* const"(即不能修改指针指向)；当成员函数加了const后，默认的参数就会变为"const ClassName* const"(即指针不能修改指向并且不能修改指向的对象内容)

如何在const函数修改成员变量的值
    使用mutable关键字
    造一个假的this去操作成员变量

引用和指针
    引用是一个变量的别名，不能为空，必须在声明的时候初始化，而且之后不能修改为其他的变量的别名；
    指针的值是一块内存的地址，可以为空，可以先声明后初始化，后面可以修改其指向的内存地址。

堆和栈：
    用户能从栈获得的空间较小，通常为1M，也有2M的
    堆的大小受限于计算机系统中有效的虚拟内存，一般来讲在32位系统下，堆内存可以达到2.9G的大小

内存分配方式
    在C++中内存分为5个区，分别是堆、栈、自由存储区、全局/静态存储区和常量存储区

TCP与UDP
    TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。
    TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。
    TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。
    TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制

vector:
    insert push_back erase v[i] clear size capacity swap empty

map
    insert find erase clear size empty swap

懒汉式单例模式
class CSingleton  
{  
public:  
static CSingleton* GetInstance()  
{  
     if ( m_pInstance == NULL )    
         m_pInstance = new CSingleton();  
     return m_pInstance;  
}  
private:  
    CSingleton(){};  
    static CSingleton * m_pInstance;  
}