基础：并发，网络编程，jvm（调优）
框架：springboot，springcloud，spring，MyBatis，tomcat，docker，zookeeper，nginx
nosql：redis，memcache
消息队列：rabbitmq
数据库：mysql（调优）
进阶：分布式（一致性算法），微服务，源代码阅读（hashmap和currenthashmap，各种框架）

HashTable为什么逐渐被废弃？
    不允许键值为null，还一个就是put方法使用sychronized方法进行线程同步，单线程无需同步，多线程可用concurren包的类型，逐渐被HashMap取代。Vector也有同样的问题，作为普通集合类，添加数据的方法也是做了同步，效率受极大影响。

ConcurrentHashMap高并发性的实现机制
    ConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。
    用分离锁实现多个线程间的并发写操作：比如put方法中，加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 Segment 而不是整个 ConcurrentHashMap。其他写线程对另外 15 个Segment 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞
    用 HashEntery 对象的不变性来降低读操作对加锁的需求：HashEntry 中的 key，hash，next 都声明为 final 型。这意味着，不能把节点添加到链接的中间和尾部，也不能在链接的中间和尾部删除节点，这个特性可以保证：在访问某个节点时，这个节点之后的链接不会被改变。这个特性可以大大降低处理链表时的复杂性。
    用 Volatile 变量协调读写线程间的内存可见性：所有执行写操作的方法（put,remove,clear），在对链表做结构性修改之后，在退出写方法前都会，去写这个 count 变量。所有未加锁的读操作（get, contains, containsKey）在读方法中，都会首先去读取这个 count 变量。读线程在读取散列表时，基本不需要加锁就能成功获得需要的值。

 ConcurrentHashMap为什么比HashTable更并发？
    在 HashTable 和HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。通过减小请求同一个锁的频率和尽量减少持有锁的时间 使得 ConcurrentHashMap 的并发性相对于 HashTable 和用同步包装器包装的 HashMap有了质的提高

Collection下包含哪些列表类和集合类：
    Collection包含了List和Set两大分支；
    List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0,List的实现类有LinkedList, ArrayList, Vector, Stack
    Set是一个不允许有重复元素的集合，Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。

 JVM中堆和栈的区别：
    栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
    栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问
    通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。

Java Gc:
    区域：内存垃圾回收主要集中于java堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。Java堆内存分为新生代和老年代，新生代中又分为1个 Eden 区域 和 2个 Survivor 区域, 对象：需要进行回收的对象就是已经没有存活的对象,判断一个对象是否存活常用的有两种办法：引用计数(每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题)和可达分析(从GCRoots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的)
    什么时候触发GC:
        1.程序调用System.gc时可以触发
        2.系统自身来决定GC触发的时机：GC又分为 minor GC 和 Full GC。Minor GC触发条件：当Eden区满时，触发Minor GC；Full GC触发条件：老年代空间不足或者方法区空间不足或者调用System.gc时或者通过MinorGC后进入老年代的平均大小大于老年代的可用内存
    GC常用算法有：
    标记-清除算法：没有移动对象，但可能出现很多碎片空间无法利用的情况
    标记-压缩算法：标记-压缩法是标记-清除法的一个改进版，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。该算法不会像标记-清除算法那样产生大量的碎片空间，如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低
    复制算法：该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。每次运行，总有一半内存是空的，导致可使用的内存空间只有原来的一半
    分代收集算法（大多采用的方法）：将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。新生代(Young)分为Eden区，From区与To区，当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。 这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区，再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区，经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。老年代经过这么几次折腾，空间被用完，那就来次Full GC

GC Roots包括：
    虚拟机栈中引用的对象。
    方法区中类静态属性实体引用的对象。
    方法区中常量引用的对象。

线程的实现方式，有什么优缺点：
    让类成为线程类有两种方式，实现Runnable接口，以及继承Thread类：
    Runnable相对优势：
        java的单继承，当继承了Thread类，则不能继承其他类，而实现Runnable接口可以实现Runnable接口的线程类的多个线程；
        可以访问同一变量，而Thread则不能（多窗口买票问题）；
    Thread优势：
        使用线程的方法方便一些，例如：获取线程的Id（Thread.currentThread().getId()）、线程名（Thread.currentThread().getName()）、线程状态（Thread.currentThread().getState()）等；
        操作同一变量，但是线程调用run方法内容不同时，使用Thread内部类的方式进行，例如生产者、消费者模式生产者消费者多线程例子

线程池：
    使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务。核心类库是ThreadPoolExecutor类，

死锁产生的原因：
    系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁；
    进程在运行过程中，请求和释放资源的顺序不当，会导致死锁

产生死锁的四个必要条件：
    互斥条件，请求与保持条件，不可剥夺条件，循环等待条件

死锁避免：
    系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。这是一种保证系统不进入死锁状态的动态策略，此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

乐观群与悲观锁和CAS的区别，使用场景，例子乐观群与悲观锁的区别，使用场景，例子：
    区别：
        悲观锁就是每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁，synchronized就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。
        乐观锁就是每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁一般来说有2种方式：使用数据版本记录机制实现，即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现；使用时间戳，和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突
        CAS的执行步骤是将指定地址的值与期待的值比较，如果相等则修改成新值，如果不相等则放弃修改;带来的问题有：ABA问题，自旋过多问题
    使用场景：
        乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。
        CAS适用于预期不太会发生冲突或者冲突不多的情况，如果并发概率很大还是用悲观锁

Lock和sysnchronized区别：
    synchronized既可以加在方法上，也可以加载特定的代码块上，括号中表示需要锁的对象。而Lock需要显示地指定起始位置和终止位置。synchronzied是托管给jvm执行的，Lock锁定是通过代码实现的；
    在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。
    synchronized获得锁和释放的方式都是在块结构中，而且是自动释放锁。而Lock则需要开发人员手动去释放，并且必须在finally块中释放，否则会引起死锁问题的发生
    Lock可以让等待锁的线程响应中断，而使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

数据库千万数据的表如何优化：
    可以sql调优；
        选择合适的数据类型（尽量使用TIMESTAMP而非DATETIME；用整型来存IP；表字段避免null值出现，null值很难查询优化且占用额外的索引空间，使用枚举或整数代替字符串类型）
        选择合适的索引：（考虑在WHERE和ORDERBY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描；尽量不用UNIQUE，由程序保证约束；应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描；值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段）
        避免select *，将需要查找的字段列出来；
        使用连接（join）来代替子查询
        拆分大的delete或insert语句
        不用函数和触发器，在应用程序实现
        少用JOIN
    分库分表；

hibernate与mybatis的区别优缺点对比：
    Hibernate功能强大，数据库无关性好，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快。Hibernate的缺点就是学习门槛不低
    iBATIS入门简单，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。iBATIS的缺点就是框架还是比较简陋，整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改

